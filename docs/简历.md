2021.4～至今 负责 OVBU 直播中台基础架构与性能优化的工作

## 直播中台源码调试支持改造

**背景：**

由于 OVBU 旗下各个产品（腾讯视频、微视、腾讯体育等等）的依赖环境各异，各个产品各自维护自己的依赖，基本都是 fork 一份知名开源库的，然后根据自己的业务进行修改，如 SDWebImage， 在视频就是 VBImage，里面封装了一些数据上报、向下智能采样的逻辑等等，这就导致原来中台采用了一些比较极端的方式：
（1）对于部分依赖，API 一致的 采用在 podspec 指定 Header Search Path 的方式，直接进行调用；
（2）对于版本不一致的，中台干脆固化了一套，并重命名的方式集成了进去。

对外提供方面，中台没有使用 pod 的发布方式，而是通过自己一套命令行工具，通过不同参数来打不同平台的包，对外提供静态库的形势发布（即 vendored_framework），使用方需要在工程内按照中台设置的 Header Search Path 来设置，否则就会出现编译失败的错误，此外也因为被迫内部集成了一些三方库，导致包体积一直很难小下去；

**措施：**

1. 对于三方库的问题，我才用了依赖注入的形式，把网络、图片等鞥这些接口方法抽象为协议，让宿主去提供实现，内部调用协议接口，这样就去掉了固化版本和特定 Header Search Path 的逻辑。同时根据不同平台提供不同的 subspec，比如 LiveSDKWeiShiAdpater，将这些特定依赖的逻辑抽到这里面去做，这样以后发布就可以使用 pod 的体系。宿主集成只需要多添加一个 subspec，集成就可以源码集成了并进行 debug 调试了；
2. 后续为推动开发体验优化，每个平台都在做支持源码/二进制之间切换，我们也做了相应的适配，各个平台方案不同，比如视频这边就是依赖 raftbox，大致上就是出包的时候要提供一个二进制产物、dsym，并在仓库打 tag，然后通过特定命令进行切换；
3. 每个平台对包体积都很敏感，腾讯内部流水线平台支持开发插件，我专门开发了一个针对资源压缩的插件，在发布的时候，会利用 Crunch 或者 TinyPNG 进行资源压缩；
4. 由于我们依赖很多，依赖库如果有 break change，都会导致我们的功能不正常。我专门开发了一个流水线插件，通过分析 Podfile.lock，来监听依赖变化，如果有任何与我们相关的变化，就会通过企业微信通知，我们第一时间进行验证是否功能正常。插件相关开发经验已经整理，并发不到了我们内部的 KM 平台上；

## OOM 优化

**背景：**

21年年中，我们频繁收到了微视运营关于主播开播闪退的反馈，我被安排进行了排查。吃内存场景比较多，分析一下主要有：

1. 美颜 SDK；直播中台使用的是内部光影团队提供的，先后经历了两个版本迭代（ AEKit vs. LightSDK），微视使用的是旧版本，本身在资源占用上优化略差；
2. 礼物动效；微视这边礼物使用了三种：[Lottie](https://github.com/airbnb/lottie-ios)、 [PAG](https://pag.io/)、帧动画。即使占用资源最少的 PAG，同时支持 MP4，但是礼物下载也会占用较多的资源；
3. WebView；直播间使用了较多的 WebView，如挂件、礼物面板等，webview 也是资源占用的大头；
4. 不合理的代码；滥用单例、内存泄漏、滥开线程等等；

**措施：**

1. 其实系统提供了 Jetsam 对应崩溃的信号 SIGKILL，XNU 对应的[代码](https://opensource.apple.com/source/xnu/xnu-3789.70.16/bsd/kern/kern_memorystatus.c.auto.html)如下：

```c
/*
 * The jetsam no frills kill call
 * 	Return: 0 on success
 *		error code on failure (EINVAL...)
 */
static int
jetsam_do_kill(proc_t p, int jetsam_flags, os_reason_t jetsam_reason) {
	int error = 0;
	error = exit_with_reason(p, W_EXITCODE(0, SIGKILL), (int *)NULL, FALSE, FALSE, jetsam_flags, jetsam_reason);
	return(error);
}
```
我们可以通过 [signal 函数](https://www.tutorialspoint.com/c_standard_library/c_function_signal.htm) 来捕获 OOM 的信号，腾讯的 Bugly 也提供了该事件的上报，但是延迟较高，我们最晚可能需要半天之后才会知道 OOM 的情况。此外，Bugly 对 OOM 堆栈上报也不是很完整，我们很难还原崩溃的场景。

我们需要先通过工具，能第一时间感知到 OOM 的发生，虽然 Bugly 后面有优化，但那都是后来的事情了。

排查的时候，我们起初使用 Xcode Instruments 工具自带的 Allocation 来看，但是这个工具有以下几个缺点：

+ 无法独立在App运行，只能在调试阶段连接Mac使用；这就导致我们无法让研发以外的同学帮忙复现问题并定位；
+ 性能较差，大型App开启后容易引发卡死；微视直播基本上要跑 Allocation，需要退出所有的在运行额应用。

FB 自己也有一个 [FBAllocationTracker](https://github.com/facebookarchive/FBAllocationTracker)，但是只能分析 OC 对象，我们了解到手Q团队的 [OOMDetector](https://github.com/Tencent/OOMDetector) 解决了这个问题，我们在分析的时候，就是用这个来看了。

iOS 不同机型不同版本对于内存阈值不一样，我们也让 QA 同学帮忙收集了主播常用的一些机型来看 OOM 出现的频率。

治理方面，我们做了以下的一些努力：

+ 微视那边切换到 LightSDK，放弃已经很久不维护的 AEKit，中间免不了有一些接口适配及修改工作，但是 CPU 及 内存占用都得到了改善；
+ 利用 OOMDetector 排查多礼物和多弹幕的场景，发现了一些不合理的图片设置的场景。在内存不吃紧的情况下，这种问题不突出，但是在礼物或者弹幕消息特别多的时候，这种问题就明显了。切换到视频那边的智能图片库，通过向下采样等手段优化图片资源对内存的占用。
+ 整理代码，去掉了一些滥用了的单例，比如 resource manager 这样的。此外，微视存在着一些自定义的滤镜，是用 GPUImage 1 编写的，我们优化了一些代码，将UIImage声明，Filter操作等放置在需要在 autoreleasepool 块中释放的内存中。它有助于手动减少内存使用。
+ 借助 Instruments 的 Leaks 分析内存泄漏，
+ Hippy 导致的 Crash，很多都是 JSC 黑盒的，（21H2 0.08% -> 22H1 0.16%）开启[com.apple.developer.kernel.increased-memory-limit](https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_kernel_increased-memory-limit?language=objc)，结合[com.apple.developer.kernel.extended-virtual-addressing](https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_kernel_extended-virtual-addressing)


>Use this entitlement if your app has specific needs that require a larger addressable space. For example, games that memory map assets to stream to the GPU may benefit from a larger address space.
>

简单总结：

苹果很少在公开文档中说明64位App在虚拟内存使用上存在限制。而且很多App也并没有像浏览器内一样，为业务灵活性而选择将hippy、flutter等技术进行大规模的组合使用，所以可能很多App其实并不会遇到虚拟内存不足的情况。

上线效果也说明浏览器在混合开发的场景下，内存优化仍然存在很大的空间。因为Extended Virtual Addressing仅能缓解虚拟内存不足的情况，并不意味着App的物理内存也得到增加，对FOOM的治理仍然需要持续。

鉴于司内有不少的著名组件都会使用mmap机制进行内存管理，建议在使用相关组件时，控制好mmap的大小。

如果有需要在iPhone 12 Pro、M1 iPad、M1上运行应用，并希望解放更多的物理内存，建议增加com.apple.developer.kernel.increased-memory-limit的能力声明，实测在iPhone 13 Pro下可以增加1GB的可用物理内存。

ReactNative和类似框架在项目中使用较多的，建议需要考虑多个Context的复用，减少创建重复内容，司内外都有实践证明该措施十分有效。

对于flutter一类的内存优化，可翻阅engine的相关代码。flutter vm在创建时允许外部传参控制vm行为，包括：old heap size、leak vm等。合适的参数可比较有效控制内存占用。

以上源码相关的内容仅个人阅读理解，如有错误请指出。

## 能耗优化

## OTeam

## 大仓

